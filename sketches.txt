5 6 2 8 0 3 10

2 to 3:

index_prev < index

numbers smaller than 3 between these:

go from 2, check 'till 3, and count numbers smaller than 3: 1 number (0)
from that, get at which index 3 will be at just after 2 has been pushed to stack b:
(how this looks is: 8 3 10 5 6)
	- it is, clearly, in index 1 now, and it started at index 5
	- mid_sort_index = index (5) - index_prev (2) - count(of smaller numbers -> 1) - 1 (from moving up the num itself?) = 1
										^							^							^
										|							|							|
										2 8 0 3 10 ...				|							|
																2 8 3 10 ...					|
																							8 3 10 ...

this is presuming we ra'd to get 2 to the first spot - would any of this change if we rra-d?
	-it should not -> rotation, whether left or right, should not change what's to the "left" and "right" to a certain number
THIS JUST GIVES US THE EFFECTIVE INDEX. We'll need to check the effective size of the remaning list after this to get if ra or rra will be able to move the num to the first spot more quickly

Reverse case:

4 0 3 7 2 10

2 to 3:

index_prev > index

mid_sort_index = arr_size_total (6) - index_prev (4) + index (2) - count_of_smaller_nums_between_them (1) - 1 (for 2 itself having been moved) = 2

OR is it enough to count back from prev index, and ignore any nums smaller than 3?

2 10 4 0 3 7

10 4 3 7




