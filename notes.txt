Site for generating random lists: https://numbergenerator.org/permutations-and-combinations#!numbers=5&lines=5&low=1&high=5&range=1-5&unique=true&order_matters=true&csv=&oddeven=&oddqty=0&sorted=false&sets=&addfilters=

- I am creating the stacks as 2D int arrays, where the last array is NULL
-  input works, for now :)

Cases for 3 numbers:
 1 2 3 -> do nothing
 1 3 2 -> shift down and swap first two, so -> 2 1 3 -> 1 2 3
 2 1 3 -> swap first 2
 .
 .
 .

 in the code, the order of checks:

 if (a[0][0] < a[1][0] && a[1][0] < a[2][0])//1 2 3
		return ("\n");
	if (a[0][0] < a[1][0] && a[1][0] > a[2][0] && a[0][0] < a[2][0])//1 3 2
		return ("rra\nsa\n");
	if (a[0][0] > a[1][0] && a[1][0] < a[2][0] && a[0][0] < a[2][0])//2 1 3
		return ("sa\n");
	if (a[0][0] < a[1][0] && a[1][0] > a[2][0] && a[0][0] > a[2][0])//2 3 1
		return ("rra\n");
	if (a[0][0] > a[1][0] && a[1][0] < a[2][0] && a[0][0] > a[2][0])//3 1 2
		return ("ra\n");
	if (a[0][0] > a[1][0] && a[1][0] > a[2][0] && a[0][0] > a[2][0])//3 2 1
		return ("ra\nsa\n");

Cases for 4 numbers - after 3 were sorted:

1 2 3		4
1 2 4		3  --> 4 1 2     3 --> 3 4 1 2 --> 4 1 2 3 --> 1 2 3 4
1 3 4		2
2 3 4		1

Cases for 5 numbers - with our method in mind, stack a will be sorted, and in stack b we still have 2 nums:

	MAXIMUM MOVES: 12

1 2 3		4 5
1 2 3		5 4
1 3 4		2 5
1 3 4		5 2
1 4 5		2 3
1 4 5		3 2
2 3 4		5 1
2 3 4		1 5
2 4 5		1 3
. . .		

After sorting 4 of 5:

1 2 3 4		5	***
1 2 3 5		4	-> 5 1 2 3		4 --> 4 5 1 2 3 --> 5 1 2 3 4 --> 1 2 3 4 5 ***
1 2 4 5		3	-> 3 1 2 4 5	--> 1 3 2 4 5 --> 3 2 4 5 1 --> 2 3 4 5 1 -->  1 2 3 4 5
1 3 4 5		2	-> 2 1 3 4 5 -> 1 2 3 4 5 ***
2 3 4 5		1	***

Something not right - is it the greater_than function?




Checking for duplicates:

1 2 3 4 5 7 8 9 0 0 3

General notes:
- in most cases, wherever I'm looking for values in the large datasets, it might be better for the functions to just return the numbers' indexes, not their value

to-do:
- check input for:
	- non-integers (incl. too big numbers)
- implement mallloc guards (when I was using strjoin, for example)

SORTING LARGE NUMBERS:

1. Determine how big our list is, and split it to sections
	- sections should, at max, have 20 nummbers each
Then, one section at a time:
2. Find first and second element of section 1
3. See how many steps it'd take to get 1st or 2nd element of the section to the top of stack b
4. "Move" the one that needs less steps, then the other
	- if the 2nd smallest was moved first, swap them
5. Move on to checking the next number pair in section
6. When the section is "empty", move on to next section
7. Once stack a is empty, we can just push everything back to it from b - with this method, b should already be sorted in the (reverse) order

More detailed:

Step 3: Since I'm not actually moving the numbers, it's not enough to see what's their index, but also which numbers are already "taken out of" the list (so, if there's a number 7 and a number 14, there's no number 7 anymore by the time we reach 14...)
	- I also have to account for the list maybe having been rotated several times by the time we get to a number...

		--> so maybe ony for the smallest number can we use purely the index to calculate the number of moves - otherwise, we need to start from the previous smallest num, and check how many greater than num2 numbers remain between them

	example: (and here I'm just pushing smallest to largest, not checking if moving smallest or second smallest is better) 
	
			4 8 2 20 1 3 7 11 43

	ra ra ra ra

			1 3 7 11 43 4 8 2 20

	pb
			3 7 11 43 4 8 2 20

	rra rra

			2 20 3 7 11 43 4 8

	pb

			20 3 7 11 43 4 8

	ra

			3 7 11 43 4 8 20

	pb

			7 11 43 4 8 20

	rra rra rra

			4 8 20 7 11 43

	pb

			8 20 7 11 43

	ra ra

			7 11 43 8 20

	pb

			11 43 8 20

	ra ra

			8 20 11 43

	pb

			20 11 43

	ra

			11 43 20

	pb

			43 20

	ra

			20 43

	pb

			43

	pb

			-

	pa pa pa pa pa pa pa pa pa

			1 2 3 4 7 8 11 20 43
